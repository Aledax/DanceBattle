
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC_D8M_RTL(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		    [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to D8M-GPIO //////////
	output 		          		CAMERA_I2C_SCL,
	inout 		          		CAMERA_I2C_SDA,
	output		          		CAMERA_PWDN_n,
	output		          		MIPI_CS_n,
	inout 		          		MIPI_I2C_SCL,
	inout 		          		MIPI_I2C_SDA,
	output		          		MIPI_MCLK,
	input 		          		MIPI_PIXEL_CLK,
	input 		     [9:0]		MIPI_PIXEL_D,
	input 		          		MIPI_PIXEL_HS,
	input 		          		MIPI_PIXEL_VS,
	output		          		MIPI_REFCLK,
	output		          		MIPI_RESET_n,
	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO 	
	
);
//=============================================================================
// REG/WIRE declarations
//=============================================================================


wire	[15:0]SDRAM_RD_DATA;
wire			DLY_RST_0;
wire			DLY_RST_1;
wire			DLY_RST_2;

wire			SDRAM_CTRL_CLK;
wire        D8M_CK_HZ ; 
wire        D8M_CK_HZ2 ; 
wire        D8M_CK_HZ3 ; 

wire [11:0] RED   ; 
wire [11:0] GREEN  ; 
wire [11:0] BLUE 		 ; 
wire [12:0] VGA_H_CNT;			
wire [12:0] VGA_V_CNT;	
wire [19:0] VGA_ADDR; 

reg [7:0] R_to_vga; 
reg [7:0] G_to_vga;
reg [7:0] B_to_vga;
wire H_active_area; 
wire V_active_area;

wire        READ_Request ;
wire 	[7:0] B_AUTO;
wire 	[7:0] G_AUTO;
wire 	[7:0] R_AUTO;
wire        RESET_N  ; 

wire        I2C_RELEASE ;  
wire        AUTO_FOC ; 
wire        CAMERA_I2C_SCL_MIPI ; 
wire        CAMERA_I2C_SCL_AF;
wire        CAMERA_MIPI_RELAESE ;
wire        MIPI_BRIDGE_RELEASE ;  
 
wire        LUT_MIPI_PIXEL_HS;
wire        LUT_MIPI_PIXEL_VS;
wire [9:0]  LUT_MIPI_PIXEL_D  ;
wire        MIPI_PIXEL_CLK_; 
wire [9:0]  PCK;
//=======================================================
// Structural coding
//=======================================================
//--INPU MIPI-PIXEL-CLOCK DELAY
CLOCK_DELAY  del1(  .iCLK (MIPI_PIXEL_CLK),  .oCLK (MIPI_PIXEL_CLK_ ) );


assign LUT_MIPI_PIXEL_HS=MIPI_PIXEL_HS;
assign LUT_MIPI_PIXEL_VS=MIPI_PIXEL_VS;
assign LUT_MIPI_PIXEL_D =MIPI_PIXEL_D ;

//------UART OFF --
assign UART_RTS =0; 
assign UART_TXD =0; 
//------HEX OFF --
// assign HEX2           = 7'h7F;
// assign HEX3           = 7'h7F;
// assign HEX4           = 7'h7F;
// assign HEX5           = 7'h7F;

//------ MIPI BRIGE & CAMERA RESET  --
assign CAMERA_PWDN_n  = 1; 
assign MIPI_CS_n      = 0; 
assign MIPI_RESET_n   = RESET_N ;

//------ CAMERA MODULE I2C SWITCH  --
assign I2C_RELEASE    = CAMERA_MIPI_RELAESE & MIPI_BRIDGE_RELEASE; 
assign CAMERA_I2C_SCL =( I2C_RELEASE  )?  CAMERA_I2C_SCL_AF  : CAMERA_I2C_SCL_MIPI ;   
 
//----- RESET RELAY  --		
RESET_DELAY			u2	(	
							.iRST  ( KEY[0] ),
                     .iCLK  ( CLOCK2_50 ),
							.oRST_0( DLY_RST_0 ),
							.oRST_1( DLY_RST_1 ),
							.oRST_2( DLY_RST_2 ),					
						   .oREADY( RESET_N)  
							
						);
 
//------ MIPI BRIGE & CAMERA SETTING  --  
MIPI_BRIDGE_CAMERA_Config    cfin(
                      .RESET_N           ( RESET_N ), 
                      .CLK_50            ( CLOCK2_50 ), 
                      .MIPI_I2C_SCL      ( MIPI_I2C_SCL ), 
                      .MIPI_I2C_SDA      ( MIPI_I2C_SDA ), 
                      .MIPI_I2C_RELEASE  ( MIPI_BRIDGE_RELEASE ),  
                      .CAMERA_I2C_SCL    ( CAMERA_I2C_SCL_MIPI ),
                      .CAMERA_I2C_SDA    ( CAMERA_I2C_SDA ),
                      .CAMERA_I2C_RELAESE( CAMERA_MIPI_RELAESE )
             );
				 
//------MIPI / VGA REF CLOCK  --
pll_test pll_ref(
	                   .inclk0 ( CLOCK3_50 ),
	                   .areset ( ~KEY[0]   ),
	                   .c0( MIPI_REFCLK    ) //20Mhz

    );
	 
//------MIPI / VGA REF CLOCK  -
VIDEO_PLL pll_ref1(
	                   .inclk0 ( CLOCK2_50 ),
	                   .areset ( ~KEY[0] ),
	                   .c0( VGA_CLK )        //25 Mhz	
    );	 
//------SDRAM CLOCK GENNERATER  --
sdram_pll u6(
		               .areset( 0 ) ,     
		               .inclk0( CLOCK_50 ),              
		               .c1    ( DRAM_CLK ),       //100MHZ   -90 degree
		               .c0    ( SDRAM_CTRL_CLK )  //100MHZ     0 degree 							
		              
	               );		
						
//------SDRAM CONTROLLER --
Sdram_Control	   u7	(	//	HOST Side						
						   .RESET_N     ( KEY[0] ),
							.CLK         ( SDRAM_CTRL_CLK ) , 
							//	FIFO Write Side 1
							.WR1_DATA    ( LUT_MIPI_PIXEL_D[9:0] ),
							.WR1         ( LUT_MIPI_PIXEL_HS & LUT_MIPI_PIXEL_VS ) ,
							
							.WR1_ADDR    ( 0 ),
                     .WR1_MAX_ADDR( 640*480 ),
						   .WR1_LENGTH  ( 256 ) , 
		               .WR1_LOAD    ( !DLY_RST_0 ),
							.WR1_CLK     ( MIPI_PIXEL_CLK_),

                     //	FIFO Read Side 1
						   .RD1_DATA    ( SDRAM_RD_DATA[9:0] ),
				        	.RD1         ( READ_Request ),
				        	.RD1_ADDR    (0 ),
                     .RD1_MAX_ADDR( 640*480 ),
							.RD1_LENGTH  ( 256  ),
							.RD1_LOAD    ( !DLY_RST_1 ),
							.RD1_CLK     ( VGA_CLK ),
											
							//	SDRAM Side
						   .SA          ( DRAM_ADDR ),
							.BA          ( DRAM_BA ),
							.CS_N        ( DRAM_CS_N ),
							.CKE         ( DRAM_CKE ),
							.RAS_N       ( DRAM_RAS_N ),
							.CAS_N       ( DRAM_CAS_N ),
							.WE_N        ( DRAM_WE_N ),
							.DQ          ( DRAM_DQ ),
							.DQM         ( DRAM_DQM  )
						   );	 	 
	 
//------ CMOS CCD_DATA TO RGB_DATA -- 

RAW2RGB_J				u4	(	
							.RST          ( VGA_VS ),
							.iDATA        ( SDRAM_RD_DATA[9:0] ),

							//-----------------------------------
                     .VGA_CLK      ( VGA_CLK ),
                     .READ_Request ( READ_Request ),
                     .VGA_VS       ( VGA_VS ),	
							.VGA_HS       ( VGA_HS ) , 
	                  			
							.oRed         ( RED  ),
							.oGreen       ( GREEN),
							.oBlue        ( BLUE )
							);		 
//------AOTO FOCUS ENABLE  --
AUTO_FOCUS_ON  vd( 
                      .CLK_50      ( CLOCK2_50 ), 
                      .I2C_RELEASE ( I2C_RELEASE ), 
                      .AUTO_FOC    ( AUTO_FOC )
               ) ;
					

//------AOTO FOCUS ADJ  --
FOCUS_ADJ adl(
                      .CLK_50        ( CLOCK2_50 ) , 
                      .RESET_N       ( I2C_RELEASE ), 
                      .RESET_SUB_N   ( I2C_RELEASE ), 
                      .AUTO_FOC      ( SW[6] & AUTO_FOC ), 
                      .SW_Y          ( 0 ),
                      .SW_H_FREQ     ( 0 ),   
                      .SW_FUC_LINE   ( SW[4] ),   
                      .SW_FUC_ALL_CEN( SW[4] ),
                      .VIDEO_HS      ( VGA_HS ),
                      .VIDEO_VS      ( VGA_VS ),
                      .VIDEO_CLK     ( VGA_CLK ),
		                .VIDEO_DE      (READ_Request) ,
                      .iR            ( R_AUTO ), 
                      .iG            ( G_AUTO ), 
                      .iB            ( B_AUTO ), 
                      .oR            ( VGA_R ) , 
                      .oG            ( VGA_G ) , 
                      .oB            ( VGA_B ) , 
                      
                      .READY         ( READY ),
                      .SCL           ( CAMERA_I2C_SCL_AF ), 
                      .SDA           ( CAMERA_I2C_SDA )
);

//------VGA Controller  --

VGA_Controller		u1	(	//	Host Side
							 .oRequest( READ_Request ),
							 .oHRequest (H_active_area), 
							 .oVRequest (V_active_area),
							 .iRed    ( R_to_vga ),
							 .iGreen  ( G_to_vga ),
							 .iBlue   ( B_to_vga ),
							 
							 //	VGA Side
							 .oVGA_R  ( R_AUTO[7:0] ),
							 .oVGA_G  ( G_AUTO[7:0] ),
							 .oVGA_B  ( B_AUTO[7:0] ),
							 .oVGA_H_SYNC( VGA_HS ),
							 .oVGA_V_SYNC( VGA_VS ),
							 .oVGA_SYNC  ( VGA_SYNC_N ),
							 .oVGA_BLANK ( VGA_BLANK_N ),
							 //	Control Signal
							 .iCLK       ( VGA_CLK ),
							 .iRST_N     ( DLY_RST_2 ),
							//  .H_Cont     ( VGA_H_CNT ),						
						    //  .V_Cont     ( VGA_V_CNT )	
							 .oAddress  ( VGA_ADDR )	
		);	


//------VS FREQUENCY TEST = 60HZ --
							
FpsMonitor uFps( 
	   .clk50    ( CLOCK2_50 ),
	   .vs       ( LUT_MIPI_PIXEL_VS ),
	
	   .fps      (),
	//    .hex_fps_h( HEX1 ),
	//    .hex_fps_l( HEX0 )
		.hex_fps_h( ),
		.hex_fps_l( )
);


//--LED DISPLAY--
CLOCKMEM  ck1 ( .CLK(VGA_CLK )   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ   )  )        ;//25MHZ
CLOCKMEM  ck2 ( .CLK(MIPI_REFCLK   )   ,.CLK_FREQ  (20000000   ) , . CK_1HZ (D8M_CK_HZ2  )  ) ;//20MHZ
CLOCKMEM  ck3 ( .CLK(MIPI_PIXEL_CLK_)   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ3  )  )  ;//25MHZ


assign LEDR = { D8M_CK_HZ ,D8M_CK_HZ2,D8M_CK_HZ3 , KEY, 1'h0,CAMERA_MIPI_RELAESE ,MIPI_BRIDGE_RELEASE  } ; 

// Custom Modules
/*
Switches Manifest
SW[9] toggles filter on/off
SW[8:5] toggles which filter is active
SW[4] shows redPixelVIndex[0] for filter 0
SW[3] shows redPixelHIndex[0] for filter 0
SW[2] multiples KEY[2:1] increment/decrement by 10
SW[1:0] selects between cbLow, cbHigh, crLow, crHigh for filter 0

Keys Manifest
KEY[0] is reset
KEY[1] is increment cbLow, cbHigh, crLow, crHigh
KEY[2] is decrement cbLow, cbHigh, crLow, crHigh
KEY[3] unused
*/
reg [7:0] crLow [0:5];
reg [7:0] crHigh [0:5];
reg [7:0] cbLow [0:5];
reg [7:0] cbHigh [0:5];

wire [15:0] redPixelHIndex [0:5]; // Live value
wire [15:0] redPixelVIndex [0:5]; 

reg [15:0] displayInt;
int16_to_hex6 int16_to_hex6_0(
	.i(displayInt),
	.o({HEX5, HEX4, HEX3, HEX2, HEX1, HEX0})
);

always @(*) begin
	if (SW[3]) begin
		displayInt = Cb; 
	end else if (SW[4]) begin
		displayInt = Cr;
	end else begin
		if (SW[1]) begin
			if (SW[0]) begin
				displayInt = crHigh[0];
			end else begin
				displayInt = crLow[0];
			end
		end else begin
			if (SW[0]) begin
				displayInt = cbHigh[0];
			end else begin
				displayInt = cbLow[0];
			end
		end
	end
end

// Increment / Decrement
reg [3:0] KEY_OLD; 
always @(posedge CLOCK2_50) begin
	if (~KEY[0]) begin
		KEY_OLD <= 4'b1111;
		crLow[0] <= 8'd0; 
		crHigh[0] <= 8'd255;
		cbLow[0] <= 8'd0;
		cbHigh[0] <= 8'd255;
		RED_cached <= 8'd0;
		GREEN_cached <= 8'd0;
		BLUE_cached <= 8'd0;
	end else begin
		if (KEY_OLD != KEY) begin
			if (~KEY[1]) begin
				if (~SW[1] && ~SW[0]) cbLow[SW[8:5]] <= SW[2] ? cbLow[SW[8:5]] + 10 : cbLow[SW[8:5]] + 1;
				if (~SW[1] &&  SW[0]) cbHigh[SW[8:5]] <= SW[2] ? cbHigh[SW[8:5]] + 10 : cbHigh[SW[8:5]] + 1;
				if ( SW[1] && ~SW[0]) crLow[SW[8:5]] <= SW[2] ? crLow[SW[8:5]] + 10 : crLow[SW[8:5]] + 1;
				if ( SW[1] &&  SW[0]) crHigh[SW[8:5]] <= SW[2] ? crHigh[SW[8:5]] + 10 : crHigh[SW[8:5]] + 1;
			end else if (~KEY[2]) begin
				if (~SW[1] && ~SW[0]) cbLow[SW[8:5]] <= SW[2] ? cbLow[SW[8:5]] - 10 : cbLow[SW[8:5]] - 1;
				if (~SW[1] &&  SW[0]) cbHigh[SW[8:5]] <= SW[2] ? cbHigh[SW[8:5]] - 10 : cbHigh[SW[8:5]] - 1;
				if ( SW[1] && ~SW[0]) crLow[SW[8:5]] <= SW[2] ? crLow[SW[8:5]] - 10 : crLow[SW[8:5]] - 1;
				if ( SW[1] &&  SW[0]) crHigh[SW[8:5]] <= SW[2] ? crHigh[SW[8:5]] - 10 : crHigh[SW[8:5]] - 1;
			end
			KEY_OLD <= KEY;
		end
		if (thresholds_ram_write_en) begin
			{cbLow[thresholds_ram_write_addr], cbHigh[thresholds_ram_write_addr], crLow[thresholds_ram_write_addr], crHigh[thresholds_ram_write_addr]} <= thresholds_ram_write_data;
		end
		if (~KEY[3]) begin
			cbLow[SW[8:5]] <= Cb - 8 >= 0 ? Cb - 8 : 0;
			cbHigh[SW[8:5]] <= Cb + 8 <= 255 ? Cb + 8 : 255;
			crLow[SW[8:5]] <= Cr - 8 >= 0 ? Cr - 8 : 0;
			crHigh[SW[8:5]] <= Cr + 8 <= 255 ? Cr + 8 : 255;
		end		
		if (hIndex[0] == 320 && vIndex[0] == 240) begin
			RED_cached <= RED;
			GREEN_cached <= GREEN;
			BLUE_cached <= BLUE;
		end
	end
end

wire [23:0] oVideo8bRgb [0:5];
always @(*) begin
	{ R_to_vga, G_to_vga, B_to_vga } = oVideo8bRgb[SW[8:5]];
end
wire [15:0] hIndex [0:5];
wire [15:0] vIndex [0:5];

ball_detector  ball_detector_0( 
   .reset( KEY[0] ),
   .iVideo12bRgb( { RED, GREEN, BLUE } ),
   .iPixelAddress( VGA_ADDRESS ),
   .iVgaRequest( READ_Request ),
   .iVgaClk( VGA_CLK ),
   .iVgaHRequest( READ_Request ),  // Can use H_active_area or READ_Request here.
   .iVgaVRequest( V_active_area ),
   .oVideo8bRgb( oVideo8bRgb[0] ),
   .iVideoSelect( SW[9] ),
   .iFreezeRam(  ),
   .iFilterOn(  ), 
   .iCrLow( crLow[0] ),
   .iCrHigh( crHigh[0] ),
   .iCbLow( cbLow[0] ),
   .iCbHigh( cbHigh[0] ),
   .oRedPixelHIndex( redPixelHIndex[0] ),
   .oRedPixelVIndex( redPixelVIndex[0] ), 
   .oHIndex( hIndex[0] ),
   .oVIndex( vIndex[0] )
 );
 
ball_detector  ball_detector_1( 
   .reset( KEY[0] ),
   .iVideo12bRgb( { RED, GREEN, BLUE } ),
   .iPixelAddress( VGA_ADDRESS ),
   .iVgaRequest( READ_Request ),
   .iVgaClk( VGA_CLK ),
   .iVgaHRequest( READ_Request ),  // Can use H_active_area or READ_Request here.
   .iVgaVRequest( V_active_area ),
   .oVideo8bRgb( oVideo8bRgb[1] ),
   .iVideoSelect( SW[9] ),
   .iFreezeRam(  ),
   .iFilterOn(  ), 
   .iCrLow( crLow[1] ),
   .iCrHigh( crHigh[1] ),
   .iCbLow( cbLow[1] ),
   .iCbHigh( cbHigh[1] ),
   .oRedPixelHIndex( redPixelHIndex[1] ),
   .oRedPixelVIndex( redPixelVIndex[1] ), 
   .oHIndex( hIndex[1] ),
   .oVIndex( vIndex[1] )
 );

wire [4:0] coords_ram_addr; 
wire [31:0] coords_ram_data; 
wire thresholds_ram_write_en;
wire [31:0] thresholds_ram_write_data;
wire [4:0] thresholds_ram_write_addr;

nios2_system ni2s (
	.clk_clk ( CLOCK2_50 ),
	.esp_uart_rxd ( GPIO[34] ),
	.esp_uart_txd ( GPIO[35] ),
	.reset_reset_n ( KEY[0] ), 
	.coords_ram_read_addr( coords_ram_addr ), // unused
	.coords_ram_read_data( {redPixelHIndex[coords_ram_addr], redPixelVIndex[coords_ram_addr]} ), 
	.coords_ram_write_addr( thresholds_ram_write_addr ), // unused
	.coords_ram_write_en( thresholds_ram_write_en ),
	.coords_ram_write_data( thresholds_ram_write_data )
);

wire [7:0] Y, Cb, Cr;
reg [7:0] RED_cached, GREEN_cached, BLUE_cached; 
rgb_to_ycbcr rgb_to_ycbcr_0( 
   .iR( RED_cached ),
   .iG( GREEN_cached ),
   .iB( BLUE_cached ),
   .oY( Y ),
   .oCb( Cb ),
   .oCr( Cr )
 );

endmodule
